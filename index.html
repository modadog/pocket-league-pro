<!DOCTYPE html>
<html>
<head>
    <title>Pocket League Pro - Final Debug Setup</title>
    <style>
        body {
            margin: 0; 
            background: #181820; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh;
        }
        /* Style for ALL settings containers */
        #moddedSettingsContainer, #volumeSettingsContainer { 
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #333;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            display: none; /* Controlled by JavaScript */
            width: 350px;
            z-index: 100;
        }
        .setting-item {
            margin-bottom: 20px;
            color: #fff;
            font-family: sans-serif;
        }
        .setting-item label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 16px;
        }
        .setting-item input[type=range] {
            width: 100%;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1200" height="750" style="border:4px solid #333; display:block;"></canvas>

    <div id="moddedSettingsContainer">
        <h3 style="color:#fff; text-align:center;">Modded Settings (0 - 100 Scale)</h3>
        <div id="physicsSliderList">
            </div>
        <button id="savePhysicsSettings" style="width:100%; padding:10px; background:#4facfe; border:none; color:#fff; font-size:18px; cursor:pointer;">Back to Menu</button>
    </div>

    <div id="volumeSettingsContainer">
        <h3 style="color:#fff; text-align:center;">Volume Settings</h3>
        <div id="volumeSliderList">
            </div>
        <button id="saveVolumeSettings" style="width:100%; padding:10px; background:#4facfe; border:none; color:#fff; font-size:18px; cursor:pointer;">Back to Menu</button>
    </div>

    <script>
// SCALING FACTOR APPLIED: 1.5
const CANVAS_WIDTH = 1200; 
const CANVAS_HEIGHT = 750; 
const CORNER_RADIUS = 15; 
const Car_max_speed = 2.5; 
const CAR_TURN_SPEED = 0.08;
const CAR_WALL_RESPONSE = 0.5; 
// BOOST_DRAIN_RATE is now in gameSettings
const BOOST_RECHARGE_RATE = 0.2; 

const GOAL_WIDTH = 300; 
const GOAL_START_Y = (CANVAS_HEIGHT - GOAL_WIDTH) / 2;
const GOAL_Y = CANVAS_HEIGHT / 2;
const AI_BOOST_THRESHOLD = 300; 
const SAFE_SPAWN_PADDING = 120; 

// --- VOLUME SETTINGS (UPDATED TO USER REQUESTS) ---
let musicVolume = 0.5; // DEFAULT: 50%
let sfxVolume = 1.0; // DEFAULT: 100%

// --- SLIDER-CONTROLLABLE GAME SETTINGS (PHYSICS) ---
let gameSettings = {
    FRICTION: 0.96,
    CAR_ACCEL: 0.45,
    WALL_BOUNCE: 0.85,
    CAR_BOUNCE: 0.8,
    BOOST_MAX_SPEED: 12,
    AI_AGGRESSION: 1.0,
    BOOST_DRAIN_RATE: 1.0, // NEW: 1.0 = Default Drain, 0.0 = Infinite Boost
    Car_max_speed: 2.5,
};

// Map of physics slider definitions (0-100 scale maps to these game value ranges)
const physicsSliderDefs = [
    { key: 'FRICTION', label: 'Car Drag', minGame: 0.9, maxGame: 1.0, defaultGame: 0.96, step: 0.001 },
    { key: 'CAR_ACCEL', label: 'Acceleration', minGame: 0.1, maxGame: 2.0, defaultGame: 0.45, step: 0.05 },
    { key: 'WALL_BOUNCE', label: 'Ball Bounce', minGame: 0.2, maxGame: 1.0, defaultGame: 0.85, step: 0.05 },
    { key: 'CAR_BOUNCE', label: 'Car Collision', minGame: 0.2, maxGame: 1.0, defaultGame: 0.8, step: 0.05 },
    { key: 'BOOST_MAX_SPEED', label: 'Max Boost Speed', minGame: 5, maxGame: 25, defaultGame: 12, step: 1 },
    { key: 'AI_AGGRESSION', label: 'AI Aggression', minGame: 0.0, maxGame: 3.0, defaultGame: 1.0, step: 0.1 },
    // NEW: Boost Drain Setting
    { key: 'BOOST_DRAIN_RATE', label: 'Boost Drain (0=Inf, 1=Default)', minGame: 0.0, maxGame: 1.0, defaultGame: 1.0, step: 0.01 },
    { key: 'Car_max_speed', label: 'Max car speed', minGame: 25.0, maxGame: 100.0, defaultGame: 25, step: 0.01 },
];
// ----------------------------------------------------


// --- GAME MODE CONSTANTS & VARIABLES ---
let gameState = 'menu_difficulty'; 
let gameMode = 'normal'; 
let heatseekerTargetCar = 'orange'; 
let ballHasBeenHit = false; 
let lastGoalScoredBy = 'none'; 

const NORMAL_BALL_FRICTION = 0.98;
const ICE_BALL_FRICTION = 1.0; 
let currentBallFriction = NORMAL_BALL_FRICTION;

// Variable for car friction, defaults to moddable setting
let currentCarFriction = gameSettings.FRICTION; 

// --- HEATSEEKER CONSTANTS ---
const HEATSEEKER_BASE_ACCEL = 0.07; 
const MAX_SEEKING_SPEED = 12; 
const HS_SPAWN_X_FORWARD = 360; 
const HS_SPAWN_Y_INWARD = 120; 

// --- NEW DYNAMIC HEATSEEKER VARIABLES (For speed-up on hit) ---
let currentHeatseekerAccel = HEATSEEKER_BASE_ACCEL;
let currentMaxSeekingSpeed = MAX_SEEKING_SPEED;
const MAX_SEEKING_ACCEL_CAP = 0.4; // Cap the ball acceleration
const MAX_SEEKING_SPEED_CAP = 50;  // Cap the ball max speed
// -------------------------------------------------------------

// --- REPLAY HISTORY CONSTANTS & ARRAY ---
const FRAMES_PER_SECOND = 60;
const REPLAY_DURATION_SECONDS = 10; 
const MAX_HISTORY_FRAMES = REPLAY_DURATION_SECONDS * FRAMES_PER_SECOND;
let gameHistory = [];
let replayIndex = 0; 
let currentReplayData = []; 
let postGoalScores = { blue: 0, orange: 0 }; 
// ----------------------------------------

// --- GAME TIMER VARIABLES ---
const GAME_DURATION_SECONDS = 300; 
let timeRemaining = GAME_DURATION_SECONDS;
let gameTimerInterval = null; 
// ----------------------------------

// --- CAR RECTANGULAR HITBOX DIMENSIONS ---
const CAR_WIDTH = 60; 
const CAR_HEIGHT = 45; 
const CAR_HALF_WIDTH = CAR_WIDTH / 2; 
const CAR_HALF_HEIGHT = CAR_HEIGHT / 2; 
const CAR_MAX_DISTANCE = Math.sqrt(CAR_HALF_WIDTH**2 + CAR_HALF_HEIGHT**2); 

// --- GAME OBJECTS ---
let AI_AGGRESSION_FACTOR = gameSettings.AI_AGGRESSION; 
let playWithAI = true; 
let scores = { blue: 0, orange: 0 };
let debugMode = false; 
let isTwoPlayerMode = false;
let selectedDifficulty = 'medium'; 

// Ball Radius Scaled
const ball = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2, vel: { x: 0, y: 0 }, radius: 22.5, color: '#eef' }; 

// Car definitions - Initialized with default values
const playerCar = { id: 'blue', x: 150, y: 375, angle: 0, vel: { x: 0, y: 0 }, color: '#4facfe', boost: 100 }; 
const aiCar = { id: 'orange', x: CANVAS_WIDTH - 150, y: 375, angle: Math.PI, vel: { x: 0, y: 0 }, color: '#ff9a44', boost: 100 }; 
let cars = [playerCar]; 

// Temporary objects for replay
let replayBall = {};
let replayPlayerCar = {};
// FIX: Initialize replayAiCar as an empty object. It will be set to null/object in replayLoop.
let replayAiCar = {}; 

// --- AUDIO SETUP ---
const AUDIO = {
    goal: new Audio('pocket league/goal_sound.mp3'),
    backgroundMusic: new Audio('pocket league/new_music.mp3')
};
// Set initial volume from global variables
AUDIO.goal.volume = sfxVolume;
AUDIO.backgroundMusic.loop = true; 
AUDIO.backgroundMusic.volume = musicVolume; 
let musicHasStarted = false; 

function startBackgroundMusic() {
    if (!musicHasStarted) {
        AUDIO.backgroundMusic.play().then(() => {
            musicHasStarted = true;
        }).catch(e => {
            console.warn("Autoplay was prevented. Music will start after the first click:", e);
        });
    }
}

function playGoalSound() {
    AUDIO.goal.currentTime = 0;
    AUDIO.goal.play().catch(e => console.error("Error playing goal sound:", e));
}
// --- END AUDIO SETUP ---

/**
 * Initializes the keys object, using correct casing for Arrow keys.
 */
function initializeKeys() {
    return { 
        w: false, s: false, a: false, d: false, 
        " ": false, m: false, f: false, 
        ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false 
    };
}
let keys = initializeKeys();

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
// NEW: References to the two settings containers
const moddedSettingsContainer = document.getElementById('moddedSettingsContainer');
const volumeSettingsContainer = document.getElementById('volumeSettingsContainer');


function distance(c1, c2) { return Math.sqrt((c1.x - c2.x)**2 + (c1.y - c2.y)**2); }

function formatTime(totalSeconds) {
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = Math.floor(totalSeconds % 60);
    const paddedSeconds = seconds < 10 ? `0${seconds}` : seconds;
    return `${minutes}:${paddedSeconds}`;
}

function startTimer() {
    if (gameTimerInterval) clearInterval(gameTimerInterval);
    
    gameTimerInterval = setInterval(() => {
        if (gameState === 'playing') {
            timeRemaining--;
            if (timeRemaining <= 0) {
                timeRemaining = 0;
                clearInterval(gameTimerInterval);
                gameState = 'game_over';
            }
        }
    }, 1000);
}

function randomizePositions() {
    const halfWidth = CANVAS_WIDTH / 2;
    const midY = CANVAS_HEIGHT / 2;
    const P = SAFE_SPAWN_PADDING; 
    let ballX, ballY;
    
    // --- RESET DYNAMIC HEATSEEKER SPEED ON KICKOFF ---
    currentHeatseekerAccel = HEATSEEKER_BASE_ACCEL;
    currentMaxSeekingSpeed = MAX_SEEKING_SPEED;
    // -------------------------------------------------

    const spawnPoints = [
        { blueX: halfWidth / 2 - 45, blueY: midY, orangeX: CANVAS_WIDTH - (halfWidth / 2) + 45, orangeY: midY }, 
        { blueX: P, blueY: P, orangeX: CANVAS_WIDTH - P, orangeY: CANVAS_HEIGHT - P }, 
        { blueX: P, blueY: CANVAS_HEIGHT - P, orangeX: CANVAS_WIDTH - P, orangeY: P }, 
        { blueX: halfWidth / 2 - 45, blueY: midY - 225, orangeX: CANVAS_WIDTH - (halfWidth / 2) + 45, orangeY: midY + 225 }, 
        { blueX: halfWidth / 2 - 180, blueY: midY + 180, orangeX: CANVAS_WIDTH - (halfWidth / 2) + 180, orangeY: midY - 180 } 
    ];

    const selectedPair = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];

    playerCar.x = selectedPair.blueX; 
    playerCar.y = selectedPair.blueY; 
    playerCar.angle = Math.atan2(midY - playerCar.y, halfWidth - playerCar.x);
    playerCar.vel.x = 0; playerCar.vel.y = 0; 
    playerCar.boost = isTwoPlayerMode ? 0 : 100;
    
    // Ensure aiCar is updated even if AI is off, just in case the array or properties are needed
    aiCar.x = selectedPair.orangeX; 
    aiCar.y = selectedPair.orangeY; 
    aiCar.angle = Math.atan2(midY - aiCar.y, halfWidth - aiCar.x);
    aiCar.vel.x = 0; 
    aiCar.vel.y = 0; 
    aiCar.boost = isTwoPlayerMode ? 0 : 100;
    
    if (gameMode === 'heatseeker') {
        let spawnType = lastGoalScoredBy;
        if (spawnType === 'none') {
            spawnType = Math.random() < 0.5 ? 'blue' : 'orange';
        }
        
        // FIX: Ensure the ball targets the opposite goal of the scoring team.
        if (spawnType === 'blue') { 
            // Blue scored -> Ball targets Orange goal
            ballX = CANVAS_WIDTH - HS_SPAWN_X_FORWARD; 
            ballY = HS_SPAWN_Y_INWARD; 
            heatseekerTargetCar = 'orange'; // Target Orange goal
        } else if (spawnType === 'orange') { 
            // Orange scored -> Ball targets Blue goal (e.g., from an AI own-goal)
            ballX = HS_SPAWN_X_FORWARD; 
            ballY = CANVAS_HEIGHT - HS_SPAWN_Y_INWARD; 
            heatseekerTargetCar = 'blue'; // Target Blue goal
        }
    } else {
        ballX = halfWidth; 
        ballY = midY;
    }

    ball.x = ballX; 
    ball.y = ballY;
    ball.vel.x = 0; 
    ball.vel.y = 0;
    ballHasBeenHit = false; 
}

function resetGame() {
    if (gameTimerInterval) clearInterval(gameTimerInterval);
    timeRemaining = GAME_DURATION_SECONDS;
    scores = { blue: 0, orange: 0 };
    postGoalScores = { blue: 0, orange: 0 }; 
    lastGoalScoredBy = 'none'; 
    gameHistory = [];
    currentReplayData = []; 
}

/**
 * Event listener for keydown. 
 */
window.addEventListener('keydown', e => { 
    const key = e.key;
    const keyName = key.startsWith('Arrow') || key === " " ? key : key.toLowerCase();
    
    if (keys.hasOwnProperty(keyName)) { 
        keys[keyName] = true; 
    }
    
    if(keyName === 'm' && (gameState === 'playing' || gameState === 'game_over' || gameState === 'replay')) {
        resetGame(); 
        gameState = 'menu_difficulty'; 
        moddedSettingsContainer.style.display = 'none';
        volumeSettingsContainer.style.display = 'none';
        canvas.style.display = 'block';
    }
});

/**
 * Event listener for keyup.
 */
window.addEventListener('keyup', e => { 
    const key = e.key;
    const keyName = key.startsWith('Arrow') || key === " " ? key : key.toLowerCase();
    
    if (keys.hasOwnProperty(keyName)) { 
        keys[keyName] = false;
    }
});

function setDifficulty(difficulty) {
    selectedDifficulty = difficulty;
    
    let aggression;
    if (difficulty === 'freeplay') aggression = 0;
    else if (difficulty === 'easy') aggression = 0.5;
    else if (difficulty === 'medium') aggression = 1.0;
    else if (difficulty === 'hard') aggression = 1.5;
    
    // Only update the gameSettings if we are not in a settings menu
    if (gameState !== 'menu_settings_physics') {
        // Apply a base level aggression based on difficulty preset
        if (!isTwoPlayerMode) {
            AI_AGGRESSION_FACTOR = aggression;
        }
    }
}

function selectGameMode(mode) {
    gameMode = mode;

    // Ball friction logic
    if (mode === 'normal' || mode === 'heatseeker') {
        currentBallFriction = NORMAL_BALL_FRICTION;
    } else if (mode === 'ice') {
        currentBallFriction = ICE_BALL_FRICTION; 
    }
    
    // --- Car Friction Logic ---
    currentCarFriction = gameSettings.FRICTION; // Default to the moddable setting
    if (mode === 'ice') {
         // FIX: Set friction close to 1.0 for a true "ice" (sliding/no friction/drag) effect.
         currentCarFriction = 0.998; 
    }
    // --------------------------
    
    cars.length = 0;
    cars.push(playerCar); 
    
    if (isTwoPlayerMode) {
        // In 2P mode, AI_AGGRESSION_FACTOR is always 0, no AI logic runs.
        AI_AGGRESSION_FACTOR = 0;
        playWithAI = false;
        cars.push(aiCar);
        playerCar.boost = 0; 
        aiCar.boost = 0;
    } else {
        setDifficulty(selectedDifficulty); 
        if (selectedDifficulty === 'freeplay') {
             playWithAI = false;
        } else {
             playWithAI = true;
             cars.push(aiCar); 
        }
        playerCar.boost = 100;
        aiCar.boost = 100;
    }
    
    // Apply the current AI_AGGRESSION setting from the physics menu or difficulty preset
    if (playWithAI && !isTwoPlayerMode) {
        AI_AGGRESSION_FACTOR = gameSettings.AI_AGGRESSION;
    }

    resetGame(); 
    randomizePositions(); 
    gameState = 'playing';
    startBackgroundMusic();
    startTimer(); 
}

// --- MODDED / PHYSICS SLIDER MANAGEMENT FUNCTIONS (RENAMED & REFACTORED) ---

/**
 * Converts a game value in a specific range to a 0-100 slider value.
 */
function mapValueToSlider(value, minGame, maxGame) {
    const rangeGame = maxGame - minGame;
    if (rangeGame === 0) return 0;
    return ((value - minGame) / rangeGame) * 100;
}

/**
 * Converts a 0-100 slider value to a game value in a specific range.
 */
function mapSliderToValue(sliderValue, minGame, maxGame) {
    const rangeGame = maxGame - minGame;
    return minGame + (sliderValue / 100) * rangeGame;
}


function createPhysicsSliders() {
    const list = document.getElementById('physicsSliderList');
    list.innerHTML = ''; 

    physicsSliderDefs.forEach(def => {
        // Hide AI aggression slider in 2P mode
        if (isTwoPlayerMode && def.key === 'AI_AGGRESSION') return;
        // Hide Boost Drain slider in 2P mode as boost is disabled anyway (pure physics testing)
        if (isTwoPlayerMode && def.key === 'BOOST_DRAIN_RATE') return;

        const div = document.createElement('div');
        div.className = 'setting-item';
        
        // Calculate the initial 0-100 value from the current game setting
        const initialSliderValue = mapValueToSlider(gameSettings[def.key], def.minGame, def.maxGame);

        // 1. Label and Slider Value Display (Always 0-100)
        const label = document.createElement('label');
        // Display the current 0-100 mapped value
        label.innerHTML = `<span>${def.label}</span><span id="val_${def.key}">${Math.round(initialSliderValue)}</span>`;
        
        // 2. Slider (always 0-100)
        const input = document.createElement('input');
        input.type = 'range';
        input.id = def.key;
        input.min = 0;
        input.max = 100;
        input.step = 1;
        input.value = initialSliderValue; // Set the slider to the 0-100 value
        
        input.addEventListener('input', () => {
            const sliderVal = parseFloat(input.value);
            // Convert slider value back to the actual game value
            const gameVal = mapSliderToValue(sliderVal, def.minGame, def.maxGame);

            // Update global settings
            // Use toFixed(2) to prevent floating point errors from accumulating on very small steps
            gameSettings[def.key] = def.step < 0.1 ? parseFloat(gameVal.toFixed(3)) : gameVal;
            
            // Update the display with the 0-100 slider value
            document.getElementById(`val_${def.key}`).textContent = Math.round(sliderVal);
            
            // Special handling for AI Aggression
            if (def.key === 'AI_AGGRESSION') {
                AI_AGGRESSION_FACTOR = gameSettings.AI_AGGRESSION;
            }
        });

        div.appendChild(label);
        div.appendChild(input);
        list.appendChild(div);
    });
}

function showPhysicsSettings() {
    moddedSettingsContainer.style.display = 'block'; 
    volumeSettingsContainer.style.display = 'none'; // Ensure other settings are hidden
    canvas.style.display = 'none';
    
    ctx.fillStyle = '#181820';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    createPhysicsSliders();
    gameState = 'menu_settings_physics';
}

document.getElementById('savePhysicsSettings').addEventListener('click', () => {
    moddedSettingsContainer.style.display = 'none';
    canvas.style.display = 'block';
    gameState = 'menu_difficulty'; 
});
// --- END MODDED / PHYSICS SLIDER MANAGEMENT FUNCTIONS ---


// --- VOLUME SLIDER MANAGEMENT FUNCTIONS (NEW) ---
function createVolumeSliders() {
    const list = document.getElementById('volumeSliderList');
    list.innerHTML = ''; 

    const volumeDefs = [
        { key: 'musicVolume', label: 'Music Volume (0 - 100)', varRef: 'musicVolume', audioRef: AUDIO.backgroundMusic },
        { key: 'sfxVolume', label: 'SFX Volume (0 - 100)', varRef: 'sfxVolume', audioRef: AUDIO.goal }
    ];

    volumeDefs.forEach(def => {
        const div = document.createElement('div');
        div.className = 'setting-item';
        
        // Initial volume is * 100
        const initialVolume100 = Math.round(window[def.varRef] * 100); 
        
        const label = document.createElement('label');
        label.innerHTML = `<span>${def.label}</span><span id="val_${def.key}">${initialVolume100}</span>`;
        
        const input = document.createElement('input');
        input.type = 'range';
        input.id = def.key;
        input.min = 0;
        input.max = 100;
        input.step = 1;
        input.value = initialVolume100; 
        
        input.addEventListener('input', () => {
            const val = parseInt(input.value);
            const floatVal = val / 100;
            
            document.getElementById(`val_${def.key}`).textContent = val;
            
            // Update global variable and audio object
            window[def.varRef] = floatVal; 
            def.audioRef.volume = floatVal;

            if (def.key === 'sfxVolume') {
                 // Play a quick test sound for SFX volume adjustment
                 AUDIO.goal.currentTime = 0;
                 AUDIO.goal.play().catch(e => {}); 
            }
        });

        div.appendChild(label);
        div.appendChild(input);
        list.appendChild(div);
    });
}

function showVolumeSettings() {
    volumeSettingsContainer.style.display = 'block';
    moddedSettingsContainer.style.display = 'none'; // Ensure other settings are hidden
    canvas.style.display = 'none';

    ctx.fillStyle = '#181820';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    createVolumeSliders();
    gameState = 'menu_settings_volume';
}

document.getElementById('saveVolumeSettings').addEventListener('click', () => {
    volumeSettingsContainer.style.display = 'none';
    canvas.style.display = 'block';
    gameState = 'menu_difficulty'; 
});
// --- END VOLUME SLIDER MANAGEMENT FUNCTIONS ---


function drawMenu() {
    // Hide settings containers when drawing menu
    moddedSettingsContainer.style.display = 'none';
    volumeSettingsContainer.style.display = 'none';
    canvas.style.display = 'block';

    ctx.fillStyle = '#181820';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    ctx.fillStyle = '#eee';
    ctx.font = '90px sans-serif'; 
    ctx.textAlign = 'center';
    ctx.fillText('Pocket League Pro', CANVAS_WIDTH / 2, 150); 
    
    let buttonTexts, buttonLabels, titleText;
    let buttonsDrawn = true;
    
    // 2-Player Skip Logic: If in 2P mode, we should skip difficulty and only show mode.
    if (gameState === 'menu_difficulty' && isTwoPlayerMode) {
        gameState = 'menu_mode'; 
    }

    if (gameState === 'menu_difficulty') {
        titleText = 'Select Difficulty (1 Player)';
        buttonTexts = ['Freeplay (No AI)', 'Easy', 'Medium', 'Hard'];
        buttonLabels = ['freeplay', 'easy', 'medium', 'hard'];
    } else if (gameState === 'menu_mode') { 
        let diffText = isTwoPlayerMode ? '2 Player Mode' : `1P Diff: ${selectedDifficulty.toUpperCase()}`;
        titleText = `Select Game Mode (${diffText})`;
        buttonTexts = ['Normal', 'Ice (No Friction)', 'Heatseeker'];
        buttonLabels = ['normal', 'ice', 'heatseeker'];
    } else {
        buttonsDrawn = false; // Don't draw main menu buttons if in a settings state
    }
    
    if (buttonsDrawn) {
        ctx.font = '45px sans-serif'; 
        ctx.fillText(titleText, CANVAS_WIDTH / 2, 255); 

        const buttonWidth = 270; 
        const buttonHeight = 75; 
        const startY = 300; 
        const separation = 105; 
        
        buttonLabels.forEach((label, index) => {
            const x = CANVAS_WIDTH / 2 - buttonWidth / 2;
            const y = startY + index * separation;
            
            const isDifficultyButton = gameState === 'menu_difficulty';
            const isSelected = isDifficultyButton && label === selectedDifficulty && !isTwoPlayerMode;
            
            if (isSelected) {
                ctx.fillStyle = '#00A86B'; 
            } else {
                ctx.fillStyle = '#4facfe'; 
            }
            ctx.fillRect(x, y, buttonWidth, buttonHeight);

            ctx.fillStyle = '#fff'; 
            ctx.font = '36px sans-serif'; 
            ctx.fillText(buttonTexts[index], CANVAS_WIDTH / 2, y + 50); 
        });
    }
    
    const DEBUG_BUTTON_WIDTH = 135; 
    const DEBUG_BUTTON_HEIGHT = 45; 
    const debugX = CANVAS_WIDTH - DEBUG_BUTTON_WIDTH - 15; 
    let buttonY = 15; 
    
    // 1. DEBUG BUTTON
    const debugText = `DEBUG: ${debugMode ? 'ON' : 'OFF'}`;
    ctx.fillStyle = debugMode ? '#FF0000' : '#888'; 
    ctx.fillRect(debugX, buttonY, DEBUG_BUTTON_WIDTH, DEBUG_BUTTON_HEIGHT);
    ctx.fillStyle = '#fff';
    ctx.font = '20px sans-serif'; 
    ctx.fillText(debugText, debugX + DEBUG_BUTTON_WIDTH / 2, buttonY + 30); 

    // 2. 2-PLAYER BUTTON
    buttonY += DEBUG_BUTTON_HEIGHT + 15;
    const twoPlayerText = `2 PLAYER: ${isTwoPlayerMode ? 'ON' : 'OFF'}`;
    ctx.fillStyle = isTwoPlayerMode ? '#00A86B' : '#888'; 
    ctx.fillRect(debugX, buttonY, DEBUG_BUTTON_WIDTH, DEBUG_BUTTON_HEIGHT);
    ctx.fillStyle = '#fff';
    ctx.font = '20px sans-serif'; 
    ctx.fillText(twoPlayerText, debugX + DEBUG_BUTTON_WIDTH / 2, buttonY + 30); 

    // 3. MODDED SETTINGS BUTTON (Renamed)
    buttonY += DEBUG_BUTTON_HEIGHT + 15;
    const moddedSettingsText = `MODDED SETTINGS`;
    ctx.fillStyle = '#4facfe'; 
    ctx.fillRect(debugX, buttonY, DEBUG_BUTTON_WIDTH, DEBUG_BUTTON_HEIGHT);
    ctx.fillStyle = '#fff';
    ctx.font = '20px sans-serif'; 
    ctx.fillText(moddedSettingsText, debugX + DEBUG_BUTTON_WIDTH / 2, buttonY + 30); 

    // 4. VOLUME SETTINGS BUTTON (New)
    buttonY += DEBUG_BUTTON_HEIGHT + 15;
    const volumeSettingsText = `VOLUME SETTINGS`;
    ctx.fillStyle = '#4facfe'; 
    ctx.fillRect(debugX, buttonY, DEBUG_BUTTON_WIDTH, DEBUG_BUTTON_HEIGHT);
    ctx.fillStyle = '#fff';
    ctx.font = '20px sans-serif'; 
    ctx.fillText(volumeSettingsText, debugX + DEBUG_BUTTON_WIDTH / 2, buttonY + 30); 
}

function handleMenuClick(e) {
    startBackgroundMusic(); 

    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const buttonWidth = 270;
    const buttonHeight = 75;
    const startY = 300;
    const separation = 105; 
    
    let buttonLabels;
    
    // --- Check Difficulty/Mode Buttons ---
    if (gameState === 'menu_difficulty' && !isTwoPlayerMode) {
        buttonLabels = ['freeplay', 'easy', 'medium', 'hard'];
    } else if (gameState === 'menu_mode') {
        buttonLabels = ['normal', 'ice', 'heatseeker'];
    } else {
        buttonLabels = [];
    }

    buttonLabels.forEach((label, index) => {
        const x = CANVAS_WIDTH / 2 - buttonWidth / 2;
        const y = startY + index * separation;

        if (mouseX >= x && mouseX <= x + buttonWidth && mouseY >= y && mouseY <= y + buttonHeight) {
            
            if (gameState === 'menu_difficulty') {
                setDifficulty(label);
                gameState = 'menu_mode'; 
            } else if (gameState === 'menu_mode') {
                selectGameMode(label);
            }
        }
    });
    
    const DEBUG_BUTTON_WIDTH = 135; 
    const DEBUG_BUTTON_HEIGHT = 45; 
    const debugX = CANVAS_WIDTH - DEBUG_BUTTON_WIDTH - 15;
    let buttonY = 15;
    
    // 1. DEBUG Button click
    if (mouseX >= debugX && mouseX <= debugX + DEBUG_BUTTON_WIDTH && mouseY >= buttonY && mouseY <= buttonY + DEBUG_BUTTON_HEIGHT) {
        debugMode = !debugMode; 
        return;
    }

    // 2. 2-PLAYER Button click
    buttonY += DEBUG_BUTTON_HEIGHT + 15;
    if (mouseX >= debugX && mouseX <= debugX + DEBUG_BUTTON_WIDTH && mouseY >= buttonY && mouseY <= buttonY + DEBUG_BUTTON_HEIGHT) {
        isTwoPlayerMode = !isTwoPlayerMode; 
        gameState = 'menu_difficulty'; 
        resetGame();
        // If switching from 2P to 1P, reset difficulty selection
        if (!isTwoPlayerMode) {
            setDifficulty(selectedDifficulty); 
        }
        return;
    }

    // 3. MODDED SETTINGS Button click (Old SETTINGS position)
    buttonY += DEBUG_BUTTON_HEIGHT + 15;
    if (mouseX >= debugX && mouseX <= debugX + DEBUG_BUTTON_WIDTH && mouseY >= buttonY && mouseY <= buttonY + DEBUG_BUTTON_HEIGHT) {
        showPhysicsSettings();
        return;
    }

    // 4. VOLUME SETTINGS Button click (New position)
    buttonY += DEBUG_BUTTON_HEIGHT + 15;
    if (mouseX >= debugX && mouseX <= debugX + DEBUG_BUTTON_WIDTH && mouseY >= buttonY && mouseY <= buttonY + DEBUG_BUTTON_HEIGHT) {
        showVolumeSettings();
        return;
    }
}

canvas.addEventListener('click', handleMenuClick);

function updateAI() {
    // AI is only updated if in 1P mode AND we have an AI opponent
    if (!playWithAI || isTwoPlayerMode) return;
    
    const car = aiCar;
    const ballDist = distance(car, ball);
    
    let targetX = ball.x;
    let targetY = ball.y;
    
    let dx_final = targetX - car.x;
    let dy_final = targetY - car.y;
    let finalTargetAngle = Math.atan2(dy_final, dx_final);
    
    let angleDiff = finalTargetAngle - car.angle;
    
    if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
    if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
    
    let accel = gameSettings.CAR_ACCEL * AI_AGGRESSION_FACTOR;
    let turn = 0;
    let boostActive = false;
    
    if (angleDiff > 0) {
        turn = CAR_TURN_SPEED;
    } else if (angleDiff < 0) {
        turn = -CAR_TURN_SPEED;
    }
    
    // AI boost threshold is adjusted based on the AI's current aggression setting
    const adjustedBoostThreshold = AI_BOOST_THRESHOLD * (2 - AI_AGGRESSION_FACTOR); 
    
    let isTooCloseToCenter = false;
    
    if (gameMode === 'heatseeker') {
        if (ball.x < CANVAS_WIDTH / 2 && ball.x > CANVAS_WIDTH / 2 - 150) { 
            isTooCloseToCenter = true;
        }
    }

    // Check if AI boost can be activated
    if (ballDist > adjustedBoostThreshold && car.boost >= gameSettings.BOOST_DRAIN_RATE && !isTwoPlayerMode && !isTooCloseToCenter) {
        boostActive = true;
    }
    
    car.vel.x += Math.cos(car.angle) * accel;
    car.vel.y += Math.sin(car.angle) * accel;
    car.angle += turn;

    // AI's max non-boost speed is proportional to aggression factor
    let currentMax = gameSettings.Car_max_speed * AI_AGGRESSION_FACTOR; 

    if (boostActive) {
        currentMax += gameSettings.BOOST_MAX_SPEED; 
        car.boost -= gameSettings.BOOST_DRAIN_RATE; // Using setting
    } else if (car.boost < 100 && !isTwoPlayerMode) {
        car.boost += BOOST_RECHARGE_RATE; 
    }
    
    car.boost = Math.max(0, Math.min(100, car.boost));

    // Car friction is controlled by Modded Settings or Game Mode (Ice)
    car.vel.x *= currentCarFriction;
    car.vel.y *= currentCarFriction;

    let speed = Math.sqrt(car.vel.x**2 + car.vel.y**2);
    if (speed > currentMax) {
        car.vel.x = (car.vel.x / speed) * currentMax;
        car.vel.y = (car.vel.y / speed) * currentMax;
    }
    
    car.x += car.vel.x;
    car.y += car.vel.y;
}


function updateCar(car, isPlayer) {
    
    // Skip if this car is the AI car in Freeplay mode
    if (car.id === 'orange' && !playWithAI && !isTwoPlayerMode) return; 
    
    let accel = 0;
    let turn = 0;
    let boostActive = false;
    let currentMax = gameSettings.Car_max_speed; 

    if (isPlayer) {
        // --- Player 1 (Blue Car) Logic ---
        
        // P1 movement keys (WASD for 1P/2P, Arrows for 1P only)
        if (keys.w || (!isTwoPlayerMode && keys.ArrowUp)) accel = gameSettings.CAR_ACCEL;
        else if (keys.s || (!isTwoPlayerMode && keys.ArrowDown)) accel = -gameSettings.CAR_ACCEL / 2;
        
        // P1 turning keys
        if (Math.abs(car.vel.x) > 0.1 || Math.abs(car.vel.y) > 0.1) {
            if (keys.a || (!isTwoPlayerMode && keys.ArrowLeft)) turn = -CAR_TURN_SPEED;
            else if (keys.d || (!isTwoPlayerMode && keys.ArrowRight)) turn = CAR_TURN_SPEED;
        }

        // P1 boost (only allowed in 1P mode) - Uses new gameSettings.BOOST_DRAIN_RATE
        if (!isTwoPlayerMode && keys[" "] && car.boost >= gameSettings.BOOST_DRAIN_RATE) {
            boostActive = true;
        }
        
    } else { 
        // --- Orange Car Logic (AI or Player 2) ---
        if (isTwoPlayerMode) {
            // --- Player 2 (Orange Car) Logic (ARROWS only, NO BOOST) ---
            
            if (keys.ArrowUp) accel = gameSettings.CAR_ACCEL;
            else if (keys.ArrowDown) accel = -gameSettings.CAR_ACCEL / 2;
            
            // P2 turning keys
            if (Math.abs(car.vel.x) > 0.1 || Math.abs(car.vel.y) > 0.1) {
                if (keys.ArrowLeft) turn = -CAR_TURN_SPEED;
                else if (keys.ArrowRight) turn = CAR_TURN_SPEED;
            }
            
            // No boost in 2P mode.
            car.boost = 0;
        } else {
            // --- AI Logic (1P mode) ---
            updateAI();
            return; 
        }
    }
    
    car.vel.x += Math.cos(car.angle) * accel;
    car.vel.y += Math.sin(car.angle) * accel;
    car.angle += turn;

    if (boostActive) {
        // Player boost speed is controlled by Modded Settings
        currentMax += gameSettings.BOOST_MAX_SPEED; 
        car.boost -= gameSettings.BOOST_DRAIN_RATE; // Using setting
    } else if (car.boost < 100 && !isTwoPlayerMode) { 
        car.boost += BOOST_RECHARGE_RATE; 
    }
    
    car.boost = Math.max(0, Math.min(100, car.boost));

    // Car friction is controlled by Modded Settings or Game Mode (Ice)
    car.vel.x *= currentCarFriction;
    car.vel.y *= currentCarFriction;

    let speed = Math.sqrt(car.vel.x**2 + car.vel.y**2);
    if (speed > currentMax) {
        car.vel.x = (car.vel.x / speed) * currentMax;
        car.vel.y = (car.vel.y / speed) * currentMax;
    }
    
    car.x += car.vel.x;
    car.y += car.vel.y;
}

function resolveCarCollision(carA, carB) {
    if (!carA || !carB) return; // Defensive check
    if ((carA.id === 'orange' && !playWithAI && !isTwoPlayerMode) || (carB.id === 'orange' && !playWithAI && !isTwoPlayerMode)) return; 

    let maxOverlapDist = CAR_MAX_DISTANCE * 2; 
    let dx = carB.x - carA.x;
    let dy = carB.y - carA.y;
    let dist = distance(carA, carB);

    if (dist < maxOverlapDist) {
        let nx = dx / dist;
        let ny = dy / dist;
        let overlap = maxOverlapDist - dist;

        carA.x -= nx * overlap * 0.5;
        carA.y -= ny * overlap * 0.5;
        carB.x += nx * overlap * 0.5;
        carB.y += ny * overlap * 0.5;

        let relVelX = carB.vel.x - carA.vel.x;
        let relVelY = carB.vel.y - carA.vel.y;
        let speedAlongNormal = relVelX * nx + relVelY * ny;

        if (speedAlongNormal > 0) return;

        // Car bounce factor is controlled by Modded Settings
        let impulse = (-(1 + gameSettings.CAR_BOUNCE) * speedAlongNormal) / 2;
        let impulseX = impulse * nx;
        let impulseY = impulse * ny;

        carA.vel.x -= impulseX;
        carA.vel.y -= impulseY;
        carB.vel.x += impulseX;
        carB.vel.y += impulseY;
    }
}

function resolveCarBallCollision(car, ballObj) {
    if (!car) return; // Defensive check
    // Skip if this car is the AI car in Freeplay mode
    if (car.id === 'orange' && !playWithAI && !isTwoPlayerMode) return; 

    let dx = ballObj.x - car.x;
    let dy = ballObj.y - car.y;
    
    const cos = Math.cos(-car.angle);
    const sin = Math.sin(-car.angle);
    let localX = dx * cos - dy * sin;
    let localY = dx * sin + dy * cos;

    let closestX = Math.max(-CAR_HALF_WIDTH, Math.min(CAR_HALF_WIDTH, localX));
    let closestY = Math.max(-CAR_HALF_HEIGHT, Math.min(CAR_HALF_HEIGHT, localY));
    
    let distX = localX - closestX;
    let distY = localY - closestY;
    
    let distSq = distX * distX + distY * distY;
    
    if (distSq < ballObj.radius * ballObj.radius) {
        let dist = Math.sqrt(distSq);
        let overlap = ballObj.radius - dist;
        
        if (dist === 0) {
            distX = 1; distY = 0; 
            dist = 1;
        }

        let nx_local = distX / dist;
        let ny_local = distY / dist;

        let nx_world = (nx_local * Math.cos(car.angle)) - (ny_local * Math.sin(car.angle));
        let ny_world = (nx_local * Math.sin(car.angle)) + (ny_local * Math.cos(car.angle));
        
        ballObj.x += nx_world * overlap;
        ballObj.y += ny_world * overlap;

        if (gameMode === 'heatseeker' && gameState === 'playing') {
            ballHasBeenHit = true; 
            if (car.id === 'blue') {
                heatseekerTargetCar = 'orange'; 
            } else if (car.id === 'orange') {
                heatseekerTargetCar = 'blue'; 
            }
            
            // --- NEW: Increase Heatseeker Speed/Accel on hit ---
            currentHeatseekerAccel = Math.min(MAX_SEEKING_ACCEL_CAP, currentHeatseekerAccel + 0.007);
            currentMaxSeekingSpeed = Math.min(MAX_SEEKING_SPEED_CAP, currentMaxSeekingSpeed + 0.75);
            // ----------------------------------------------------
        }

        let relVelX = ballObj.vel.x - car.vel.x;
        let relVelY = ballObj.vel.y - car.vel.y;

        let speedAlongNormal = relVelX * nx_world + relVelY * ny_world;

        if (speedAlongNormal < 0) {
            let impulseStrength = -speedAlongNormal * 1.8; 
            
            ballObj.vel.x += nx_world * impulseStrength;
            ballObj.vel.y += ny_world * impulseStrength;

            car.vel.x -= nx_world * impulseStrength * 0.4;
            car.vel.y -= ny_world * impulseStrength * 0.4;
        }
    }
}

function getCarCorners(car) {
    const hw = CAR_HALF_WIDTH;
    const hh = CAR_HALF_HEIGHT;
    const cosA = Math.cos(car.angle);
    const sinA = Math.sin(car.angle);

    const localCorners = [
        { x: hw, y: hh },   
        { x: -hw, y: hh },  
        { x: -hw, y: -hh }, 
        { x: hw, y: -hh }   
    ];

    return localCorners.map(p => ({
        x: car.x + p.x * cosA - p.y * sinA,
        y: car.y + p.x * sinA + p.y * cosA
    }));
}

function checkWallCollisionRect(car, bounceFactor) {
    if (!car) return; // Defensive check
    // Skip if this car is the AI car in Freeplay mode
    if (car.id === 'orange' && !playWithAI && !isTwoPlayerMode) return; 
    
    const corners = getCarCorners(car);
    
    corners.forEach(p => {
        let correctionX = 0;
        let correctionY = 0;
        
        const isOutsideCornerX = p.x > CORNER_RADIUS && p.x < CANVAS_WIDTH - CORNER_RADIUS;
        const isOutsideCornerY = p.y > CORNER_RADIUS && p.y < CANVAS_HEIGHT - CORNER_RADIUS;

        if (isOutsideCornerX) {
            if (p.y < 0) correctionY = -p.y;
            else if (p.y > CANVAS_HEIGHT) correctionY = CANVAS_HEIGHT - p.y;
        }

        const isWithinGoalY = car.y > GOAL_START_Y && car.y < GOAL_START_Y + GOAL_WIDTH;
        if (isOutsideCornerY && !isWithinGoalY) {
             if (p.x < 0) correctionX = -p.x;
             else if (p.x > CANVAS_WIDTH) correctionX = CANVAS_WIDTH - p.x;
        }

        if (Math.abs(correctionX) > 0 || Math.abs(correctionY) > 0) {
            car.x += correctionX;
            car.y += correctionY;
            
            if (Math.abs(correctionX) > 0) car.vel.x *= -bounceFactor;
            if (Math.abs(correctionY) > 0) car.vel.y *= -bounceFactor;
        }
    });

    if (CORNER_RADIUS > 0) {
        const cornerPoints = [
            { x: CORNER_RADIUS, y: CORNER_RADIUS }, 
            { x: CANVAS_WIDTH - CORNER_RADIUS, y: CORNER_RADIUS }, 
            { x: CORNER_RADIUS, y: CANVAS_HEIGHT - CORNER_RADIUS }, 
            { x: CANVAS_WIDTH - CORNER_RADIUS, y: CANVAS_HEIGHT - CORNER_RADIUS }
        ];

        cornerPoints.forEach(corner => {
            const dist = distance(corner, car);
            if (dist < CORNER_RADIUS + CAR_MAX_DISTANCE) {
                const overlap = (CORNER_RADIUS + CAR_MAX_DISTANCE) - dist;
                const nx_c = (car.x - corner.x) / dist;
                const ny_c = (car.y - corner.y) / dist;

                car.x += nx_c * overlap;
                car.y += ny_c * overlap;

                const speedAlongNormal = car.vel.x * nx_c + car.vel.y * ny_c;
                if (speedAlongNormal < 0) {
                    const impulse = (-(1 + CAR_WALL_RESPONSE) * speedAlongNormal);
                    car.vel.x += impulse * nx_c;
                    car.vel.y += impulse * ny_c;
                }
            }
        });
    }
}

function checkWallCollisionCircle(object, bounceFactor) {
    let objRadius = object.radius;
    let isWithinGoalY = object.y > GOAL_START_Y + objRadius && object.y < GOAL_START_Y + GOAL_WIDTH - objRadius;
    
    // 1. Top/Bottom Walls (Straight sections)
    if (object.x > CORNER_RADIUS && object.x < CANVAS_WIDTH - CORNER_RADIUS) {
        if (object.y < objRadius) {
            object.y = objRadius;
            // Ball bounce factor is controlled by Modded Settings
            object.vel.y *= -bounceFactor;
        } else if (object.y > CANVAS_HEIGHT - objRadius) {
            object.y = CANVAS_HEIGHT - objRadius;
            object.vel.y *= -bounceFactor;
        }
    }

    // 2. Left/Right Walls (Solid walls behind the goals)
    if (!isWithinGoalY && object.y > CORNER_RADIUS && object.y < CANVAS_HEIGHT - CORNER_RADIUS) { 
        if (object.x < objRadius) {
            object.x = objRadius;
            object.vel.x *= -bounceFactor;
        } 
        else if (object.x > CANVAS_WIDTH - objRadius) {
            object.x = CANVAS_WIDTH - objRadius;
            object.vel.x *= -bounceFactor;
        }
    }

    // 3. Corner Collision Logic
    if (CORNER_RADIUS > 0) {
        const corners = [
            { x: CORNER_RADIUS, y: CORNER_RADIUS }, 
            { x: CANVAS_WIDTH - CORNER_RADIUS, y: CORNER_RADIUS }, 
            { x: CORNER_RADIUS, y: CANVAS_HEIGHT - CORNER_RADIUS }, 
            { x: CANVAS_WIDTH - CORNER_RADIUS, y: CANVAS_HEIGHT - CORNER_RADIUS }
        ];

        corners.forEach(corner => {
            let dx = object.x - corner.x;
            let dy = object.y - corner.y;
            let dist = distance(corner, object);

            if (dist < CORNER_RADIUS + objRadius) {
                let nx = dx / dist; 
                let ny = dy / dist; 

                object.x = corner.x + nx * (CORNER_RADIUS + objRadius);
                object.y = corner.y + ny * (CORNER_RADIUS + objRadius);

                let speedAlongNormal = object.vel.x * nx + object.vel.y * ny;

                if (speedAlongNormal < 0) {
                    // Ball bounce factor is controlled by Modded Settings
                    let impulse = (-(1 + bounceFactor) * speedAlongNormal);
                    
                    object.vel.x += impulse * nx;
                    object.vel.y += impulse * ny;
                }
            }
        });
    }
}

// --- NEW DEBUG FUNCTION: BALL PATH PREDICTION ---

function drawBallPath(ctx, ballObj, durationFrames) {
    // Only draw if the ball has significant speed
    const currentBallSpeed = Math.sqrt(ballObj.vel.x**2 + ballObj.vel.y**2);
    if (currentBallSpeed < 0.5) return; 

    const PREDICTION_STEP = 1; 
    const PREDICTION_LENGTH = durationFrames; 
    
    // Create a temporary, disposable ball object for simulation
    let tempBall = { 
        x: ballObj.x, 
        y: ballObj.y, 
        vel: { x: ballObj.vel.x, y: ballObj.vel.y }, 
        radius: ballObj.radius 
    };
    
    ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)'; // Semi-transparent yellow
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 10]); // Dashed line

    ctx.beginPath();
    ctx.moveTo(tempBall.x, tempBall.y);

    for (let i = 0; i < PREDICTION_LENGTH; i += PREDICTION_STEP) {
        
        // 1. Apply Friction/Heatseeker/Movement 
        tempBall.vel.x *= currentBallFriction;
        tempBall.vel.y *= currentBallFriction;
        
        // Heatseeker logic for prediction
        if (gameMode === 'heatseeker' && ballHasBeenHit) {
            const targetGoalX = (heatseekerTargetCar === 'blue') ? 0 : CANVAS_WIDTH;
            const targetGoalY = GOAL_Y;
            
            let dx = targetGoalX - tempBall.x;
            let dy = targetGoalY - tempBall.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > tempBall.radius) {
                let nx = dx / dist;
                let ny = dy / dist;
                
                // --- MODIFIED: Use dynamic acceleration variables ---
                const currentSeekAccel = currentHeatseekerAccel; 

                tempBall.vel.x += nx * currentSeekAccel;
                tempBall.vel.y += ny * currentSeekAccel;
                
                let speed = Math.sqrt(tempBall.vel.x**2 + tempBall.vel.y**2);
                if (speed > currentMaxSeekingSpeed) { // --- MODIFIED: Use dynamic max speed variable ---
                     tempBall.vel.x = (tempBall.vel.x / speed) * currentMaxSeekingSpeed;
                     tempBall.vel.y = (tempBall.vel.y / speed) * currentMaxSeekingSpeed;
                }
            }
        }

        tempBall.x += tempBall.vel.x * PREDICTION_STEP;
        tempBall.y += tempBall.vel.y * PREDICTION_STEP;
        
        // 2. Check and Resolve Wall Collisions
        let objRadius = tempBall.radius;
        let bounceFactor = gameSettings.WALL_BOUNCE;
        let hasBounced = false;
        
        // Top/Bottom Walls
        if (tempBall.x > CORNER_RADIUS && tempBall.x < CANVAS_WIDTH - CORNER_RADIUS) {
            if (tempBall.y < objRadius) {
                tempBall.y = objRadius;
                tempBall.vel.y *= -bounceFactor;
                hasBounced = true;
            } else if (tempBall.y > CANVAS_HEIGHT - objRadius) {
                tempBall.y = CANVAS_HEIGHT - objRadius;
                tempBall.vel.y *= -bounceFactor;
                hasBounced = true;
            }
        }

        // Left/Right Walls
        let isWithinGoalY = tempBall.y > GOAL_START_Y + objRadius && tempBall.y < GOAL_START_Y + GOAL_WIDTH - objRadius;
        if (!isWithinGoalY && tempBall.y > CORNER_RADIUS && tempBall.y < CANVAS_HEIGHT - CORNER_RADIUS) { 
            if (tempBall.x < objRadius) {
                tempBall.x = objRadius;
                tempBall.vel.x *= -bounceFactor;
                hasBounced = true;
            } 
            else if (tempBall.x > CANVAS_WIDTH - objRadius) {
                tempBall.x = CANVAS_WIDTH - objRadius;
                tempBall.vel.x *= -bounceFactor;
                hasBounced = true;
            }
        }
        
        // Corner Collision Logic
        const corners = [
            { x: CORNER_RADIUS, y: CORNER_RADIUS }, 
            { x: CANVAS_WIDTH - CORNER_RADIUS, y: CORNER_RADIUS }, 
            { x: CORNER_RADIUS, y: CANVAS_HEIGHT - CORNER_RADIUS }, 
            { x: CANVAS_WIDTH - CORNER_RADIUS, y: CANVAS_HEIGHT - CORNER_RADIUS }
        ];

        corners.forEach(corner => {
            let dx = tempBall.x - corner.x;
            let dy = tempBall.y - corner.y;
            let dist = distance(corner, tempBall);

            if (dist < CORNER_RADIUS + objRadius) {
                
                // FIX 1: Prevent division by zero if ball is exactly centered on a corner point
                if (dist === 0) {
                    tempBall.x += 1;
                    tempBall.y += 1;
                    dist = distance(corner, tempBall); 
                }

                let nx = dx / dist; 
                let ny = dy / dist; 

                // FIX 2: Use tempBall instead of the global 'object' variable
                tempBall.x = corner.x + nx * (CORNER_RADIUS + objRadius); 
                tempBall.y = corner.y + ny * (CORNER_RADIUS + objRadius);

                let speedAlongNormal = tempBall.vel.x * nx + tempBall.vel.y * ny;

                if (speedAlongNormal < 0) {
                    // Ball bounce factor is controlled by Modded Settings
                    let impulse = (-(1 + bounceFactor) * speedAlongNormal);
                    
                    tempBall.vel.x += impulse * nx;
                    tempBall.vel.y += impulse * ny;
                    hasBounced = true;
                }
            }
        });

        // 3. Draw Path Segment
        if (i % 5 === 0) { 
            ctx.lineTo(tempBall.x, tempBall.y);
        }
    }
    
    ctx.stroke();
    ctx.setLineDash([]); // Reset line dash for other drawings
}

// ... (rest of the code - same as before) ...


function update() {
    updateCar(playerCar, true);
    if (playWithAI || isTwoPlayerMode) updateCar(aiCar, false);

    // Ball friction is controlled by Game Mode
    ball.vel.x *= currentBallFriction;
    ball.vel.y *= currentBallFriction;
    
    if (gameMode === 'heatseeker' && ballHasBeenHit) {
        const targetGoalX = (heatseekerTargetCar === 'blue') ? 0 : CANVAS_WIDTH;
        const targetGoalY = GOAL_Y;
        
        let dx = targetGoalX - ball.x;
        let dy = targetGoalY - ball.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > ball.radius) {
            let nx = dx / dist;
            let ny = dy / dist;
            
            // --- MODIFIED: Use dynamic acceleration variable ---
            const currentSeekAccel = currentHeatseekerAccel; 

            ball.vel.x += nx * currentSeekAccel;
            ball.vel.y += ny * currentSeekAccel;
            
            let speed = Math.sqrt(ball.vel.x**2 + ball.vel.y**2);
            if (speed > currentMaxSeekingSpeed) { // --- MODIFIED: Use dynamic max speed variable ---
                 ball.vel.x = (ball.vel.x / speed) * currentMaxSeekingSpeed;
                 ball.vel.y = (ball.vel.y / speed) * currentMaxSeekingSpeed;
            }
        }
    }

    ball.x += ball.vel.x;
    ball.y += ball.vel.y;

    if (playWithAI || isTwoPlayerMode) resolveCarCollision(playerCar, aiCar); 

    cars.forEach(car => checkWallCollisionRect(car, CAR_WALL_RESPONSE)); 
    // Ball wall bounce is controlled by Modded Settings
    checkWallCollisionCircle(ball, gameSettings.WALL_BOUNCE); 

    cars.forEach(car => {
        resolveCarBallCollision(car, ball); 
    });
    
    let goalScored = false;
    let scorer = 'none';
    let newScoreBlue = scores.blue; 
    let newScoreOrange = scores.orange;

    if (ball.x < ball.radius) { // Ball in Blue Goal
        if (ball.y > GOAL_START_Y && ball.y < GOAL_START_Y + GOAL_WIDTH) {
            newScoreOrange++; // Orange scores
            scorer = 'orange'; 
            goalScored = true;
        } 
    } else if (ball.x > CANVAS_WIDTH - ball.radius) { // Ball in Orange Goal
        if (ball.y > GOAL_START_Y && ball.y < GOAL_START_Y + GOAL_WIDTH) {
            newScoreBlue++; // Blue scores
            scorer = 'blue'; 
            goalScored = true;
        } 
    }

    if (goalScored) {
        playGoalSound();
        
        lastGoalScoredBy = scorer;
        postGoalScores.blue = newScoreBlue; 
        postGoalScores.orange = newScoreOrange;

        currentReplayData = [...gameHistory];
        replayIndex = 0;
        
        gameState = 'replay';
        
        ball.vel.x = 0; ball.vel.y = 0;
        playerCar.vel.x = 0; playerCar.vel.y = 0;
        if (playWithAI || isTwoPlayerMode) { aiCar.vel.x = 0; aiCar.vel.y = 0; }
    }
}

function recordState() {
    const currentState = {
        ball: { x: ball.x, y: ball.y, vel: { x: ball.vel.x, y: ball.vel.y }, radius: ball.radius, color: ball.color },
        playerCar: { x: playerCar.x, y: playerCar.y, angle: playerCar.angle, vel: { x: playerCar.vel.x, y: playerCar.vel.y }, color: playerCar.color, boost: playerCar.boost, id: playerCar.id },
        // FIX: Only record aiCar state if it is currently in play (AI or 2P)
        aiCar: (playWithAI || isTwoPlayerMode) ? { x: aiCar.x, y: aiCar.y, angle: aiCar.angle, vel: { x: aiCar.vel.x, y: aiCar.vel.y }, color: aiCar.color, boost: aiCar.boost, id: aiCar.id } : null,
        scores: { blue: scores.blue, orange: scores.orange } 
    };

    gameHistory.push(currentState);

    if (gameHistory.length > MAX_HISTORY_FRAMES) {
        gameHistory.shift(); 
    }
}

function replayLoop() {
    if (keys.f) {
        replayIndex = currentReplayData.length; 
        keys.f = false; 
    }

    if (replayIndex >= currentReplayData.length) {
        scores.blue = postGoalScores.blue;
        scores.orange = postGoalScores.orange;
        
        randomizePositions();
        gameState = 'playing';
        gameHistory = []; 
        return;
    }

    const state = currentReplayData[replayIndex];
    
    Object.assign(replayBall, state.ball);
    Object.assign(replayPlayerCar, state.playerCar);
    
    // FIX: Safely handle replayAiCar assignment. 
    // If state.aiCar is null (meaning AI was off), set replayAiCar to null.
    if (state.aiCar) {
        Object.assign(replayAiCar, state.aiCar);
    } else {
        replayAiCar = null;
    }
    
    scores.blue = state.scores.blue;
    scores.orange = state.scores.orange;

    replayIndex++;
    
    if (replayIndex === currentReplayData.length) {
        scores.blue = postGoalScores.blue;
        scores.orange = postGoalScores.orange;
    }
}


function drawCar(car, isReplay = false) {
    let carToDraw;
    if (isReplay) {
        carToDraw = car;
    } else {
        carToDraw = (car.id === 'blue' ? playerCar : aiCar);
    }
    
    // Check if the car is defined or should be drawn (e.g., aiCar in Freeplay is excluded)
    if (!carToDraw || (carToDraw.id === 'orange' && !playWithAI && !isTwoPlayerMode && !isReplay && carToDraw.x === undefined)) return; 

    // FIX: If in replay and replayAiCar is null, skip drawing the orange car.
    if (isReplay && carToDraw.id === 'orange' && carToDraw === null) return; 

    const CAR_DRAW_WIDTH = CAR_WIDTH; 
    const CAR_DRAW_HEIGHT = CAR_HEIGHT; 

    ctx.save();
    ctx.translate(carToDraw.x, carToDraw.y);
    ctx.rotate(carToDraw.angle);

    ctx.globalAlpha = isReplay ? 0.8 : 1.0; 
    
    ctx.fillStyle = carToDraw.color;
    ctx.beginPath();
    ctx.rect(-CAR_DRAW_WIDTH / 2, -CAR_DRAW_HEIGHT / 2, CAR_DRAW_WIDTH, CAR_DRAW_HEIGHT);
    ctx.fill();
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = '#222';
    ctx.fillRect(7.5, -15, 22.5, 30); 
    
    // Draw Boost Fire (Only in playing mode and NOT in 2P mode)
    if (!isReplay && !isTwoPlayerMode) {
        let isBoosting = false;
        
        if (carToDraw.id === 'blue' && keys[" "]) {
            isBoosting = true;
        } else if (carToDraw.id === 'orange' && playWithAI) {
            let speedCheck = Math.sqrt(carToDraw.vel.x**2 + carToDraw.vel.y**2);
            // Check if AI speed is near the max *non-boost* speed for its current aggression
            if (speedCheck > gameSettings.Car_max_speed * AI_AGGRESSION_FACTOR + 1.5) isBoosting = true; 
        }
        
        if (isBoosting && carToDraw.boost >= gameSettings.BOOST_DRAIN_RATE) { // Use new setting for check
            ctx.fillStyle = '#ffaa00';
            ctx.beginPath();
            ctx.moveTo(-CAR_DRAW_WIDTH / 2, -7.5); 
            ctx.lineTo(-CAR_DRAW_WIDTH / 2 - 25 - Math.random() * 15, 0); 
            ctx.lineTo(-CAR_DRAW_WIDTH / 2, 7.5); 
            ctx.fill();
        }
    }

    ctx.restore();
    ctx.globalAlpha = 1.0; 

    // --- 2. DRAW BOOST BAR (OUTSIDE THE ROTATED CONTEXT) ---
    
    const BAR_WIDTH = 60; 
    const BAR_HEIGHT = 9; 
    const BAR_Y_OFFSET = 37.5; 

    if (carToDraw.x !== undefined) { 
        // 2P mode cars have no boost, but we still draw the bar if it's the AI/1P
        if (!isTwoPlayerMode || carToDraw.id === 'blue') {
            ctx.fillStyle = '#333';
            ctx.fillRect(carToDraw.x - BAR_WIDTH / 2, carToDraw.y + BAR_Y_OFFSET, BAR_WIDTH, BAR_HEIGHT);
            
            ctx.fillStyle = '#ffaa00'; 
            ctx.fillRect(carToDraw.x - BAR_WIDTH / 2, carToDraw.y + BAR_Y_OFFSET, BAR_WIDTH * (carToDraw.boost / 100), BAR_HEIGHT);
        }
    }
    
    //  Draw Car Hitbox if Debug Mode is ON
    if (debugMode) {
        ctx.save();
        ctx.translate(carToDraw.x, carToDraw.y);
        ctx.rotate(carToDraw.angle);
        ctx.beginPath();
        ctx.rect(-CAR_HALF_WIDTH, -CAR_HALF_HEIGHT, CAR_WIDTH, CAR_HEIGHT);
        ctx.strokeStyle = '#FF00FF'; 
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.5;
        ctx.stroke();
        ctx.restore();
        
        ctx.globalAlpha = 1.0;
    }
}

function drawGame() {
    ctx.fillStyle = '#2a2a35';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // --- DRAW FIELD BOUNDARIES ---
    ctx.strokeStyle = '#3a3a45';
    ctx.lineWidth = 4;
    ctx.beginPath();
    
    ctx.moveTo(CORNER_RADIUS, 0);
    ctx.lineTo(CANVAS_WIDTH - CORNER_RADIUS, 0);
    ctx.arcTo(CANVAS_WIDTH, 0, CANVAS_WIDTH, CORNER_RADIUS, CORNER_RADIUS);
    ctx.lineTo(CANVAS_WIDTH, GOAL_START_Y);
    ctx.moveTo(CANVAS_WIDTH, GOAL_START_Y + GOAL_WIDTH);
    ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT - CORNER_RADIUS);
    ctx.arcTo(CANVAS_WIDTH, CANVAS_HEIGHT, CANVAS_WIDTH - CORNER_RADIUS, CANVAS_HEIGHT, CORNER_RADIUS);
    ctx.lineTo(CORNER_RADIUS, CANVAS_HEIGHT);
    ctx.arcTo(0, CANVAS_HEIGHT, 0, CANVAS_HEIGHT - CORNER_RADIUS, CORNER_RADIUS);
    ctx.lineTo(0, GOAL_START_Y + GOAL_WIDTH);
    ctx.moveTo(0, GOAL_START_Y);
    ctx.lineTo(0, CORNER_RADIUS);
    ctx.arcTo(0, 0, CORNER_RADIUS, 0, CORNER_RADIUS);
    
    ctx.stroke();

    // Center Circle/Line/Goals 
    ctx.beginPath();
    ctx.arc(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, 105, 0, Math.PI * 2); 
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(CANVAS_WIDTH / 2, 0);
    ctx.lineTo(CANVAS_WIDTH / 2, CANVAS_HEIGHT);
    ctx.stroke();
    
    const GOAL_DEPTH = 90; 
    ctx.fillStyle = '#4facfe33';
    ctx.fillRect(0, GOAL_START_Y, GOAL_DEPTH, GOAL_WIDTH);
    ctx.fillStyle = '#ff9a4433';
    ctx.fillRect(CANVAS_WIDTH - GOAL_DEPTH, GOAL_START_Y, GOAL_DEPTH, GOAL_WIDTH);


    // --- NEW DEBUG IMPLEMENTATION ---
    if (debugMode && gameState === 'playing') {
        // 1. Draw Ball Path (2 seconds / 120 frames)
        drawBallPath(ctx, ball, 120);

        // 2. Draw AI Target Path (Line from AI to Ball)
        if (playWithAI && !isTwoPlayerMode) {
            ctx.strokeStyle = 'rgba(255, 0, 255, 0.5)'; // Magenta/Purple
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]); // Different dashed pattern for AI path
            ctx.beginPath();
            ctx.moveTo(aiCar.x, aiCar.y);
            ctx.lineTo(ball.x, ball.y);
            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash
        }
    }
    // --- END DEBUG PATH DRAWING ---

    
    let ballToDraw = (gameState === 'playing' || gameState === 'game_over') ? ball : replayBall;
    
    if (gameState === 'replay') {
        drawCar(replayPlayerCar, true);
        // FIX: Only call drawCar for orange car if replayAiCar is not null
        if (replayAiCar) drawCar(replayAiCar, true);
    } else if (gameState === 'playing' || gameState === 'game_over') {
        drawCar(playerCar, false);
        if (playWithAI || isTwoPlayerMode) drawCar(aiCar, false);
    }

    if (ballToDraw.x !== undefined) {
        ctx.beginPath();
        ctx.arc(ballToDraw.x, ballToDraw.y, ballToDraw.radius, 0, Math.PI * 2);
        ctx.fillStyle = ballToDraw.color;
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.stroke();

        if (debugMode) {
            ctx.beginPath();
            ctx.arc(ballToDraw.x, ballToDraw.y, ballToDraw.radius, 0, Math.PI * 2);
            ctx.strokeStyle = '#FF00FF'; 
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.5;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }
    }
    
    if (gameState === 'replay') {
        // --- NEW SCORER TEXT & REPLAY POSITIONING ---
        const SCORER_Y = CANVAS_HEIGHT - 160;   
        const REPLAY_Y = CANVAS_HEIGHT - 90; 
        const SKIP_Y = CANVAS_HEIGHT - 50;   
        
        let scorerText = '';
        let scorerColor = '#eee';

        if (lastGoalScoredBy === 'blue') {
            scorerText = 'BLUE SCORED!';
            scorerColor = '#4facfe'; // Blue color
        } else if (lastGoalScoredBy === 'orange') {
            scorerText = 'ORANGE SCORED!';
            scorerColor = '#ff9a44'; // Orange color
        }
        
        // Draw Scorer Text
        ctx.fillStyle = scorerColor;
        ctx.font = '60px sans-serif'; 
        ctx.textAlign = 'center';
        ctx.fillText(scorerText, CANVAS_WIDTH / 2, SCORER_Y); 
        
        // Draw REPLAY Text
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.font = '60px sans-serif'; 
        ctx.fillText('REPLAY', CANVAS_WIDTH / 2, REPLAY_Y); 
        
        // Draw Skip Text
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.font = '20px sans-serif'; 
        ctx.fillText('(Press F to Skip)', CANVAS_WIDTH / 2, SKIP_Y); 
    } else if (gameState === 'game_over') {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.font = '120px sans-serif'; 
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 30);
        
        let winnerText = 'TIE!';
        if (scores.blue > scores.orange) {
            winnerText = 'BLUE WINS!';
        } else if (scores.orange > scores.blue) {
            winnerText = 'ORANGE WINS!';
        }
        
        ctx.font = '60px sans-serif'; 
        ctx.fillText(winnerText, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 60);
        ctx.font = '30px sans-serif'; 
        ctx.fillText('(Press M for Menu)', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 120);
    }

    // --- SCORE & TIME DISPLAY ---
    ctx.fillStyle = '#4facfe';
    ctx.font = '60px sans-serif'; 
    ctx.textAlign = 'center';
    ctx.fillText(scores.blue, CANVAS_WIDTH / 2 - 200, 67.5); 
    
    ctx.fillStyle = '#eee';
    ctx.font = '72px sans-serif'; 
    ctx.fillText(formatTime(timeRemaining), CANVAS_WIDTH / 2, 67.5); 
    
    ctx.fillStyle = '#ff9a44';
    ctx.font = '60px sans-serif'; 
    ctx.fillText(scores.orange, CANVAS_WIDTH / 2 + 200, 67.5); 
    
    // Info Text (at CANVAS_HEIGHT - 15)
    ctx.fillStyle = '#888';
    ctx.font = '21px sans-serif'; 
    ctx.textAlign = 'center';
    
    let infoText;
    if (isTwoPlayerMode) {
        infoText = `Mode: ${gameMode.toUpperCase()} (2 PLAYER) | P1: WASD (Blue) | P2: ARROWS (Orange) | No Boost | M to Menu`;
    } else {
        infoText = `Mode: ${gameMode.toUpperCase()} (Difficulty: ${selectedDifficulty.toUpperCase()}) | P1: WASD/Arrows to Drive | SPACE to Boost | M to Menu`;
    }
    ctx.fillText(infoText, CANVAS_WIDTH / 2, CANVAS_HEIGHT - 15); 


    // --- DEBUG TEXT DISPLAY (TOP LEFT) ---
    if (debugMode) {
        // 1. Calculate Ball Speed
        const ballSpeed = Math.sqrt(ball.vel.x**2 + ball.vel.y**2).toFixed(2);
        
        ctx.save();
        ctx.fillStyle = '#FFFF00'; // Yellow
        ctx.font = '20px monospace'; 
        ctx.textAlign = 'left';
        
        let debugY = 20; 
        const LINE_HEIGHT = 25;

        // Display FPS
        ctx.fillText(`FPS: ${fps}`, 10, debugY); 
        debugY += LINE_HEIGHT;
        
        // Display Ball Speed
        ctx.fillText(`Ball Speed: ${ballSpeed}`, 10, debugY); 
        debugY += LINE_HEIGHT;
        
        // Display Game Mode
        ctx.fillText(`Mode: ${gameMode.toUpperCase()}`, 10, debugY); 
        debugY += LINE_HEIGHT;

        // Display Difficulty (only if not 2P mode)
        if (!isTwoPlayerMode) {
            ctx.fillText(`Difficulty: ${selectedDifficulty.toUpperCase()} (Aggro: ${AI_AGGRESSION_FACTOR.toFixed(1)})`, 10, debugY); 
        } else {
             ctx.fillText(`Difficulty: 2 PLAYER MODE`, 10, debugY); 
        }
        
        ctx.restore();
    }
    // --- END DEBUG TEXT DISPLAY ---
}


// --- NEW FPS VARIABLES ---
let lastFrameTimeMs = 0;
let fps = 60; // Default estimate
let frameCounter = 0;
const fpsUpdateInterval = 500; // Update every 500ms
let lastFpsUpdate = 0; 
// --- END FPS VARIABLES ---


// MODIFIED loop function to calculate FPS
function loop(timestamp) {
    // FPS Calculation (only run if timestamp is available and we're in game)
    if (timestamp) {
        if (timestamp > lastFpsUpdate + fpsUpdateInterval) {
            fps = Math.round(frameCounter * 1000 / (timestamp - lastFpsUpdate));
            lastFpsUpdate = timestamp;
            frameCounter = 0;
        }
        frameCounter++;
    }

    // NEW: 2-Player Skip Logic: Immediately transition to mode selection if 2P is on.
    if (gameState === 'menu_difficulty' && isTwoPlayerMode) {
        gameState = 'menu_mode';
    }
    
    if (gameState === 'menu_difficulty' || gameState === 'menu_mode') {
        drawMenu();
    } else if (gameState === 'menu_settings_physics' || gameState === 'menu_settings_volume') {
        // Handled by DOM, loop continues to maintain canvas focus when returning
    } else if (gameState === 'playing') {
        update();
        recordState();
        drawGame();
    } else if (gameState === 'replay') {
        replayLoop();
        drawGame();
    } else if (gameState === 'game_over') {
        drawGame(); 
    }
    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
